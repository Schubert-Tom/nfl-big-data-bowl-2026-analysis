<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kinematic Based Coverage and Risk Analysis</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; }
    header { display: grid; gap: 12px; margin-bottom: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    input[type="search"] { padding: 10px 12px; min-width: 260px; border-radius: 10px; border: 1px solid #9996; }
    button, select, label { border-radius: 10px; border: 1px solid #9996; padding: 10px 12px; background: transparent; }
    label { display: inline-flex; gap: 8px; align-items: center; padding: 8px 10px; }
    .meta { opacity: 0.8; font-size: 0.95rem; }

    .desc{
      border: 1px solid #9996;
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 1.02rem;
      line-height: 1.35;
      opacity: 0.95;
    }

    .layout { display: grid; gap: 14px; grid-template-columns: 420px 1fr; align-items: start; }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }

    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; }
    .card {
      border: 1px solid #9996;
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      user-select: none;
    }
    .card:hover { filter: brightness(1.03); }
    .card.selected { outline: 2px solid #6aa6ff66; }

    .title { font-weight: 650; margin: 0; }

    .viewer {
      border: 1px solid #9996;
      border-radius: 14px;
      padding: 12px;
      position: sticky;
      top: 16px;
    }
    .viewerHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .viewerHeader .name { font-weight: 650; }
    .viewerHeader .hint { opacity: 0.75; font-size: 0.95rem; }

    iframe {
      width: 100%;
      height: 1000px;
      border: 0;
      border-radius: 10px;
      background: #00000008;
      overflow: hidden;
    }

    .err { border: 1px solid #c33; padding: 12px; border-radius: 12px; }
    .hint { opacity: 0.85; }
    .pill { font-size: 12px; padding: 4px 8px; border: 1px solid #9996; border-radius: 999px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;">Plotly Gallery</h1>

    <div class="row">
      <input id="q" type="search" placeholder="Search figures…" />
      <label title="Show a single preview for the selected figure">
        <input id="preview" type="checkbox" checked />
        Preview
      </label>

      <label title="Preview height">
        Height
        <select id="height">
          <option value="1000" selected>1000px</option>
          <option value="1200">1200px</option>
          <option value="900">900px</option>
          <option value="800">800px</option>
          <option value="720">720px</option>
          <option value="600">600px</option>
          <option value="480">480px</option>
          <option value="360">360px</option>
        </select>
      </label>

      <button id="reload" type="button">Reload list</button>
      <span id="status" class="meta"></span>
    </div>

    <div id="error" class="err hidden"></div>

    <div class="hint meta">
      Reads <span class="pill">/figures/*.html</span> via GitHub API for the file list, then loads the actual page via a relative link like <span class="pill">figures/your_plot.html</span>.
    </div>

    <div class="desc">
      This gallery visualizes a kinematics-based coverage model for NFL plays. For each player, a personalized motion model estimates the region they can reach over time based on their current speed and heading. Combined with a quarterback throw-time and throw-distance model, the plots highlight how pass targets evolve across the field for both offense and defense. Blue indicates low offensive risk (offense arrives first), white is neutral (simultaneous arrival), and red indicates higher risk where defenders have the time advantage.
    </div>
  </header>

  <main class="layout">
    <section>
      <div id="grid" class="grid"></div>
    </section>

    <section id="viewer" class="viewer hidden">
      <div class="viewerHeader">
        <div class="name" id="viewerName"></div>
        <div class="hint" id="viewerHint"></div>
      </div>
      <iframe id="viewerFrame" scrolling="no" loading="lazy"></iframe>
    </section>
  </main>

  <script>
    const els = {
      q: document.getElementById("q"),
      preview: document.getElementById("preview"),
      height: document.getElementById("height"),
      reload: document.getElementById("reload"),
      status: document.getElementById("status"),
      error: document.getElementById("error"),
      grid: document.getElementById("grid"),
      viewer: document.getElementById("viewer"),
      viewerName: document.getElementById("viewerName"),
      viewerHint: document.getElementById("viewerHint"),
      viewerFrame: document.getElementById("viewerFrame"),
    };

    let allFiles = [];
    let selectedFile = null;

    function inferOwnerRepo() {
      const host = location.hostname;               // "<owner>.github.io"
      const owner = host.split(".")[0] || "";
      const parts = location.pathname.split("/").filter(Boolean);
      const repo = parts.length ? parts[0] : `${owner}.github.io`;
      return { owner, repo };
    }

    async function fetchDefaultBranch(owner, repo) {
      const r = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
        headers: { "Accept": "application/vnd.github+json" }
      });
      if (!r.ok) throw new Error(`GitHub repo lookup failed (${r.status})`);
      const j = await r.json();
      return j.default_branch || "main";
    }

    async function fetchFiguresList(owner, repo, branch) {
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/figures?ref=${encodeURIComponent(branch)}`;
      const r = await fetch(url, { headers: { "Accept": "application/vnd.github+json" } });
      if (!r.ok) throw new Error(`GitHub contents API failed (${r.status}). Does /figures exist?`);
      const j = await r.json();

      return (Array.isArray(j) ? j : [])
        .filter(x => x && x.type === "file" && typeof x.name === "string" && x.name.toLowerCase().endsWith(".html"))
        .map(x => x.name)
        .sort((a,b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));
    }

    function nameFromFile(filename) {
      return filename.replace(/\.html$/i, "");
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function showError(msg) {
      els.error.classList.remove("hidden");
      els.error.innerHTML = `
        <div><strong>Could not auto-list figures.</strong></div>
        <div style="margin-top:6px;">${escapeHtml(msg)}</div>
        <div class="hint" style="margin-top:10px;">
          Make sure your repo has a <code>figures/</code> folder, is public (or you’re not hitting API limits),
          and GitHub Pages is serving the same branch.
        </div>
      `;
    }

    function hideError() {
      els.error.classList.add("hidden");
      els.error.innerHTML = "";
    }

    function updateViewer() {
      const showPreview = els.preview.checked;

      if (!showPreview || !selectedFile) {
        els.viewer.classList.add("hidden");
        els.viewerFrame.removeAttribute("src");
        return;
      }

      const h = Number(els.height.value) || 1000;
      const href = `figures/${encodeURIComponent(selectedFile)}`;

      els.viewer.classList.remove("hidden");
      els.viewerName.textContent = nameFromFile(selectedFile);
      els.viewerHint.textContent = href;
      els.viewerFrame.style.height = `${h}px`;

      if (els.viewerFrame.getAttribute("src") !== href) {
        els.viewerFrame.setAttribute("src", href);
      }
    }

    function renderList() {
      const query = els.q.value.trim().toLowerCase();
      const files = allFiles.filter(name => name.toLowerCase().includes(query));

      els.status.textContent = `${files.length} / ${allFiles.length} figures`;

      els.grid.innerHTML = files.map(name => {
        const title = nameFromFile(name);
        const selected = (name === selectedFile) ? "selected" : "";
        return `
          <div class="card ${selected}" data-file="${escapeHtml(name)}" role="button" tabindex="0">
            <p class="title">${escapeHtml(title)}</p>
          </div>
        `;
      }).join("");

      updateViewer();
    }

    function selectFile(name) {
      selectedFile = name;
      renderList();
      updateViewer();
    }

    async function load() {
      hideError();
      els.status.textContent = "Loading…";

      try {
        const { owner, repo } = inferOwnerRepo();
        if (!owner || !repo) throw new Error("Could not infer owner/repo from URL.");

        const branch = await fetchDefaultBranch(owner, repo);
        allFiles = await fetchFiguresList(owner, repo, branch);

        if (!selectedFile || !allFiles.includes(selectedFile)) {
          selectedFile = allFiles[0] || null;
        }

        renderList();

        if (!allFiles.length) {
          showError("No .html files found in /figures.");
          els.status.textContent = "0 figures";
        }
      } catch (e) {
        allFiles = [];
        selectedFile = null;
        els.grid.innerHTML = "";
        els.status.textContent = "";
        els.viewer.classList.add("hidden");
        showError(e?.message || String(e));
      }
    }

    // UI hooks
    els.q.addEventListener("input", renderList);
    els.preview.addEventListener("change", updateViewer);
    els.height.addEventListener("change", updateViewer);
    els.reload.addEventListener("click", load);

    // Click-to-select (event delegation)
    els.grid.addEventListener("click", (ev) => {
      const card = ev.target.closest(".card");
      if (!card) return;
      const file = card.getAttribute("data-file");
      if (file) selectFile(file);
    });

    // Double-click: open plot in a new tab
    els.grid.addEventListener("dblclick", (ev) => {
      const card = ev.target.closest(".card");
      if (!card) return;
      const file = card.getAttribute("data-file");
      if (!file) return;
      const href = `figures/${encodeURIComponent(file)}`;
      window.open(href, "_blank", "noopener");
    });

    // Keyboard accessibility
    els.grid.addEventListener("keydown", (ev) => {
      if (ev.key !== "Enter" && ev.key !== " ") return;
      const card = ev.target.closest(".card");
      if (!card) return;
      ev.preventDefault();
      const file = card.getAttribute("data-file");
      if (file) selectFile(file);
    });

    load();
  </script>
</body>
</html>
